(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require HighOrd.
Require int.Int.
Require int.MinMax.
Require map.Map.
Require map.Const.
Require list.List.
Require list.Length.
Require list.Mem.
Require set.Fset.
Require set.FsetInduction.
Require set.SetImp.
Require list.Append.
Require list.Reverse.
Require list.NumOcc.

(* Why3 assumption *)
Fixpoint elements {a:Type} {a_WT:WhyType a}
  (l:Init.Datatypes.list a) {struct l}: set.Fset.fset a :=
  match l with
  | Init.Datatypes.nil => set.Fset.empty : set.Fset.fset a
  | Init.Datatypes.cons x r => set.Fset.add x (elements r)
  end.

Axiom elements_mem :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (l:Init.Datatypes.list a),
  list.Mem.mem x l <-> set.Fset.mem x (elements l).

Axiom vertex : Type.
Parameter vertex_WhyType : WhyType vertex.
Existing Instance vertex_WhyType.

Parameter vertices: set.Fset.fset vertex.

Parameter successors: vertex -> set.Fset.fset vertex.

Axiom successors_vertices :
  forall (x:vertex), set.Fset.mem x vertices ->
  set.Fset.subset (successors x) vertices.

(* Why3 assumption *)
Definition edge (x:vertex) (y:vertex) : Prop :=
  set.Fset.mem x vertices /\ set.Fset.mem y (successors x).

(* Why3 assumption *)
Inductive path: vertex -> Init.Datatypes.list vertex -> vertex -> Prop :=
  | Path_empty : forall (x:vertex), path x Init.Datatypes.nil x
  | Path_cons :
      forall (x:vertex) (y:vertex) (z:vertex) (l:Init.Datatypes.list vertex),
      edge x y -> path y l z -> path x (Init.Datatypes.cons x l) z.

Axiom path_right_extension :
  forall (x:vertex) (y:vertex) (z:vertex) (l:Init.Datatypes.list vertex),
  path x l y -> edge y z ->
  path x (Init.Datatypes.app l (Init.Datatypes.cons y Init.Datatypes.nil)) z.

Axiom path_right_inversion :
  forall (x:vertex) (z:vertex) (l:Init.Datatypes.list vertex), path x l z ->
  (x = z) /\ (l = Init.Datatypes.nil) \/
  (exists y:vertex, exists l':Init.Datatypes.list vertex,
   path x l' y /\
   edge y z /\
   (l = (Init.Datatypes.app l' (Init.Datatypes.cons y Init.Datatypes.nil)))).

Axiom path_trans :
  forall (x:vertex) (y:vertex) (z:vertex) (l1:Init.Datatypes.list vertex)
    (l2:Init.Datatypes.list vertex),
  path x l1 y -> path y l2 z -> path x (Init.Datatypes.app l1 l2) z.

Axiom empty_path :
  forall (x:vertex) (y:vertex), path x Init.Datatypes.nil y -> (x = y).

Axiom path_decomposition :
  forall (x:vertex) (y:vertex) (z:vertex) (l1:Init.Datatypes.list vertex)
    (l2:Init.Datatypes.list vertex),
  path x (Init.Datatypes.app l1 (Init.Datatypes.cons y l2)) z ->
  path x l1 y /\ path y (Init.Datatypes.cons y l2) z.

Axiom lmem_dec :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (l:Init.Datatypes.list a),
  list.Mem.mem x l \/ ~ list.Mem.mem x l.

Axiom inter_com :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set.Fset.fset a) (s2:set.Fset.fset a),
  set.Fset.infix_eqeq (set.Fset.inter s1 s2) (set.Fset.inter s2 s1).

Axiom inter_add_l :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set.Fset.fset a) (s2:set.Fset.fset a) (x:a),
  set.Fset.mem x s2 ->
  set.Fset.infix_eqeq (set.Fset.inter (set.Fset.add x s1) s2)
  (set.Fset.add x (set.Fset.inter s1 s2)).

Axiom inter_not_add_l :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set.Fset.fset a) (s2:set.Fset.fset a) (x:a),
  ~ set.Fset.mem x s2 ->
  set.Fset.infix_eqeq (set.Fset.inter (set.Fset.add x s1) s2)
  (set.Fset.inter s1 s2).

Axiom diff_add_l :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s1:set.Fset.fset a) (s2:set.Fset.fset a),
  ~ set.Fset.mem x s2 ->
  set.Fset.infix_eqeq (set.Fset.diff (set.Fset.add x s1) s2)
  (set.Fset.add x (set.Fset.diff s1 s2)).

Axiom diff_not_add_l :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s1:set.Fset.fset a) (s2:set.Fset.fset a),
  set.Fset.mem x s2 ->
  set.Fset.infix_eqeq (set.Fset.diff (set.Fset.add x s1) s2)
  (set.Fset.diff s1 s2).

Axiom subset_add_r :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:set.Fset.fset a) (s':set.Fset.fset a),
  set.Fset.subset s' (set.Fset.add x s) ->
  set.Fset.mem x s' \/ set.Fset.subset s' s.

Axiom union_add_l :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:set.Fset.fset a) (s':set.Fset.fset a),
  set.Fset.infix_eqeq (set.Fset.union (set.Fset.add x s) s')
  (set.Fset.add x (set.Fset.union s s')).

Axiom union_add_r :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:set.Fset.fset a) (s':set.Fset.fset a),
  set.Fset.infix_eqeq (set.Fset.union s (set.Fset.add x s'))
  (set.Fset.add x (set.Fset.union s s')).

Axiom union_com :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset a) (s':set.Fset.fset a),
  set.Fset.infix_eqeq (set.Fset.union s s') (set.Fset.union s' s).

Axiom union_var_l :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset a) (s':set.Fset.fset a) (t:set.Fset.fset a),
  set.Fset.subset s s' ->
  set.Fset.subset (set.Fset.union s t) (set.Fset.union s' t).

Axiom union_var_r :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset a) (t:set.Fset.fset a) (t':set.Fset.fset a),
  set.Fset.subset t t' ->
  set.Fset.subset (set.Fset.union s t) (set.Fset.union s t').

Parameter set_of:
  forall {a:Type} {a_WT:WhyType a}, set.Fset.fset (set.Fset.fset a) ->
  set.Fset.fset a.

Axiom set_of_empty :
  forall {a:Type} {a_WT:WhyType a},
  ((set_of (set.Fset.empty : set.Fset.fset (set.Fset.fset a))) =
   (set.Fset.empty : set.Fset.fset a)).

Axiom set_of_add :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset a) (sx:set.Fset.fset (set.Fset.fset a)),
  set.Fset.infix_eqeq (set_of (set.Fset.add s sx))
  (set.Fset.union s (set_of sx)).

(* Why3 assumption *)
Definition one_in_set_of {a:Type} {a_WT:WhyType a}
    (sccs:set.Fset.fset (set.Fset.fset a)) : Prop :=
  forall (x:a), set.Fset.mem x (set_of sccs) ->
  exists cc:set.Fset.fset a, set.Fset.mem x cc /\ set.Fset.mem cc sccs.

Axiom Induction :
  (forall (s:set.Fset.fset (set.Fset.fset vertex)), set.Fset.is_empty s ->
   one_in_set_of s) ->
  (forall (s:set.Fset.fset (set.Fset.fset vertex)), one_in_set_of s ->
   (forall (t:set.Fset.fset vertex), one_in_set_of (set.Fset.add t s))) ->
  forall (s:set.Fset.fset (set.Fset.fset vertex)), one_in_set_of s.

Axiom set_of_elt :
  forall (sccs:set.Fset.fset (set.Fset.fset vertex)), one_in_set_of sccs.

Axiom elt_set_of :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (cc:set.Fset.fset a) (sccs:set.Fset.fset (set.Fset.fset a)),
  set.Fset.mem x cc -> set.Fset.mem cc sccs -> set.Fset.mem x (set_of sccs).

Axiom subset_set_of :
  forall (s:set.Fset.fset (set.Fset.fset vertex))
    (s':set.Fset.fset (set.Fset.fset vertex)),
  set.Fset.subset s s' -> set.Fset.subset (set_of s) (set_of s').

Axiom elts_cons :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (l:Init.Datatypes.list a),
  set.Fset.infix_eqeq (elements (Init.Datatypes.cons x l))
  (set.Fset.add x (elements l)).

Axiom elts_app :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:Init.Datatypes.list a) (s':Init.Datatypes.list a),
  set.Fset.infix_eqeq (elements (Init.Datatypes.app s s'))
  (set.Fset.union (elements s) (elements s')).

Axiom list_simpl_r :
  forall {a:Type} {a_WT:WhyType a},
  forall (l1:Init.Datatypes.list a) (l2:Init.Datatypes.list a)
    (l:Init.Datatypes.list a),
  ((Init.Datatypes.app l1 l) = (Init.Datatypes.app l2 l)) -> (l1 = l2).

Axiom snoc_app :
  forall {a:Type} {a_WT:WhyType a},
  forall (l1:Init.Datatypes.list a) (l2:Init.Datatypes.list a) (x:a),
  ((Init.Datatypes.app
    (Init.Datatypes.app l1 (Init.Datatypes.cons x Init.Datatypes.nil)) l2)
   = (Init.Datatypes.app l1 (Init.Datatypes.cons x l2))).

(* Why3 assumption *)
Definition is_last {a:Type} {a_WT:WhyType a} (x:a)
    (s:Init.Datatypes.list a) : Prop :=
  exists s':Init.Datatypes.list a,
  (s = (Init.Datatypes.app s' (Init.Datatypes.cons x Init.Datatypes.nil))).

(* Why3 assumption *)
Definition precedes {a:Type} {a_WT:WhyType a} (x:a) (y:a)
    (s:Init.Datatypes.list a) : Prop :=
  exists s1:Init.Datatypes.list a, exists s2:Init.Datatypes.list a,
  (s = (Init.Datatypes.app s1 (Init.Datatypes.cons x s2))) /\
  list.Mem.mem y (Init.Datatypes.cons x s2).

Axiom precedes_mem :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (y:a) (s:Init.Datatypes.list a), precedes x y s ->
  list.Mem.mem x s /\ list.Mem.mem y s.

Axiom head_precedes :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (y:a) (s:Init.Datatypes.list a),
  list.Mem.mem y (Init.Datatypes.cons x s) ->
  precedes x y (Init.Datatypes.cons x s).

Axiom precedes_tail :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (y:a) (z:a) (s:Init.Datatypes.list a), ~ (x = z) ->
  precedes x y (Init.Datatypes.cons z s) <-> precedes x y s.

Axiom tail_not_precedes :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (y:a) (s:Init.Datatypes.list a),
  precedes y x (Init.Datatypes.cons x s) -> ~ list.Mem.mem x s -> (y = x).

Axiom split_list_precedes :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (y:a) (s1:Init.Datatypes.list a) (s2:Init.Datatypes.list a),
  list.Mem.mem y
  (Init.Datatypes.app s1 (Init.Datatypes.cons x Init.Datatypes.nil)) ->
  precedes y x (Init.Datatypes.app s1 (Init.Datatypes.cons x s2)).

Axiom precedes_refl :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:Init.Datatypes.list a), precedes x x s <-> list.Mem.mem x s.

Axiom precedes_append_left :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (y:a) (s1:Init.Datatypes.list a) (s2:Init.Datatypes.list a),
  precedes x y s1 -> precedes x y (Init.Datatypes.app s2 s1).

Axiom precedes_append_left_iff :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (y:a) (s1:Init.Datatypes.list a) (s2:Init.Datatypes.list a),
  ~ list.Mem.mem x s1 ->
  precedes x y (Init.Datatypes.app s1 s2) <-> precedes x y s2.

Axiom precedes_append_right :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (y:a) (s1:Init.Datatypes.list a) (s2:Init.Datatypes.list a),
  precedes x y s1 -> precedes x y (Init.Datatypes.app s1 s2).

Axiom precedes_append_right_iff :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (y:a) (s1:Init.Datatypes.list a) (s2:Init.Datatypes.list a),
  ~ list.Mem.mem y s2 ->
  precedes x y (Init.Datatypes.app s1 s2) <-> precedes x y s1.

(* Why3 assumption *)
Definition simplelist {a:Type} {a_WT:WhyType a} (l:Init.Datatypes.list a) :
    Prop :=
  forall (x:a), ((list.NumOcc.num_occ x l) <= 1%Z)%Z.

Axiom simplelist_tl :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (l:Init.Datatypes.list a),
  simplelist (Init.Datatypes.cons x l) -> simplelist l /\ ~ list.Mem.mem x l.

Axiom simplelist_split_1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (l1:Init.Datatypes.list a) (l2:Init.Datatypes.list a)
    (l3:Init.Datatypes.list a) (l4:Init.Datatypes.list a),
  ((Init.Datatypes.app l1 (Init.Datatypes.cons x l2)) =
   (Init.Datatypes.app l3 (Init.Datatypes.cons x l4))) ->
  ~ list.Mem.mem x l1 -> ~ list.Mem.mem x l2 -> ~ list.Mem.mem x l3 ->
  ~ list.Mem.mem x l4 -> (l1 = l3).

Axiom num_occ_zero :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (l:Init.Datatypes.list a),
  ((list.NumOcc.num_occ x l) = 0%Z) <-> ~ list.Mem.mem x l.

(* Why3 goal *)
Theorem simplelist_split {a:Type} {a_WT:WhyType a} :
  forall (x:a) (l1:Init.Datatypes.list a) (l2:Init.Datatypes.list a)
    (l3:Init.Datatypes.list a) (l4:Init.Datatypes.list a),
  simplelist (Init.Datatypes.app l1 (Init.Datatypes.cons x l2)) ->
  ((Init.Datatypes.app l1 (Init.Datatypes.cons x l2)) =
   (Init.Datatypes.app l3 (Init.Datatypes.cons x l4))) ->
  (l1 = l3) /\ (l2 = l4).
(* Why3 intros x l1 l2 l3 l4 h1 h2. *)
Proof.
Require Import Lia.
Require list.Mem.
intros x.

assert (forall (l1 l2 : list a), simplelist (l1 ++ x :: l2) -> ((NumOcc.num_occ x l1 = 0%Z)%Z /\ (NumOcc.num_occ x l2 = 0%Z)%Z )). 
{
intros.
unfold simplelist in H.
specialize H with x.
rewrite (NumOcc.Append_Num_Occ x (l1) (x :: l2)) in H.

remember (NumOcc.num_occ x l1).
remember (NumOcc.num_occ x l2).
assert ((0 <= z)%Z).
rewrite Heqz.
apply NumOcc.Num_Occ_NonNeg.
assert ((0 <= z0)%Z).
rewrite Heqz0.
apply NumOcc.Num_Occ_NonNeg.
unfold NumOcc.num_occ in H.
remember (why_decidable_eq x x).
destruct s.
symmetry in Heqz0.
unfold NumOcc.num_occ in Heqz0.
rewrite Heqz0 in H.
lia.

exfalso; apply n; auto.
}

intros l1 l2 l3 l4 G H1.
assert (G1 := G).
apply H in G1.
rewrite H1 in G.
apply H in G.
destruct G; destruct G1.

assert (l1 = l3).
eapply simplelist_split_1; eauto.
apply num_occ_zero; auto.
apply num_occ_zero; auto.
apply num_occ_zero; auto.
apply num_occ_zero; auto.

split; auto.
subst l1.

generalize H1.
generalize l3.
induction l0; simpl; intros; inversion H5; auto.

Qed.

