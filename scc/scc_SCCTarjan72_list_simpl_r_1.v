(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require HighOrd.
Require int.Int.
Require int.MinMax.
Require map.Map.
Require map.Const.
Require list.List.
Require list.Length.
Require list.Mem.
Require set.Fset.
Require set.FsetInduction.
Require set.SetImp.
Require list.Append.
Require list.Reverse.
Require list.NumOcc.

(* Why3 assumption *)
Fixpoint elements {a:Type} {a_WT:WhyType a}
  (l:Init.Datatypes.list a) {struct l}: set.Fset.fset a :=
  match l with
  | Init.Datatypes.nil => set.Fset.empty : set.Fset.fset a
  | Init.Datatypes.cons x r => set.Fset.add x (elements r)
  end.

Axiom elements_mem :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (l:Init.Datatypes.list a),
  list.Mem.mem x l <-> set.Fset.mem x (elements l).

Axiom vertex : Type.
Parameter vertex_WhyType : WhyType vertex.
Existing Instance vertex_WhyType.

Parameter vertices: set.Fset.fset vertex.

Parameter successors: vertex -> set.Fset.fset vertex.

Axiom successors_vertices :
  forall (x:vertex), set.Fset.mem x vertices ->
  set.Fset.subset (successors x) vertices.

(* Why3 assumption *)
Definition edge (x:vertex) (y:vertex) : Prop :=
  set.Fset.mem x vertices /\ set.Fset.mem y (successors x).

(* Why3 assumption *)
Inductive path: vertex -> Init.Datatypes.list vertex -> vertex -> Prop :=
  | Path_empty : forall (x:vertex), path x Init.Datatypes.nil x
  | Path_cons :
      forall (x:vertex) (y:vertex) (z:vertex) (l:Init.Datatypes.list vertex),
      edge x y -> path y l z -> path x (Init.Datatypes.cons x l) z.

Axiom path_right_extension :
  forall (x:vertex) (y:vertex) (z:vertex) (l:Init.Datatypes.list vertex),
  path x l y -> edge y z ->
  path x (Init.Datatypes.app l (Init.Datatypes.cons y Init.Datatypes.nil)) z.

Axiom path_right_inversion :
  forall (x:vertex) (z:vertex) (l:Init.Datatypes.list vertex), path x l z ->
  (x = z) /\ (l = Init.Datatypes.nil) \/
  (exists y:vertex, exists l':Init.Datatypes.list vertex,
   path x l' y /\
   edge y z /\
   (l = (Init.Datatypes.app l' (Init.Datatypes.cons y Init.Datatypes.nil)))).

Axiom path_trans :
  forall (x:vertex) (y:vertex) (z:vertex) (l1:Init.Datatypes.list vertex)
    (l2:Init.Datatypes.list vertex),
  path x l1 y -> path y l2 z -> path x (Init.Datatypes.app l1 l2) z.

Axiom empty_path :
  forall (x:vertex) (y:vertex), path x Init.Datatypes.nil y -> (x = y).

Axiom path_decomposition :
  forall (x:vertex) (y:vertex) (z:vertex) (l1:Init.Datatypes.list vertex)
    (l2:Init.Datatypes.list vertex),
  path x (Init.Datatypes.app l1 (Init.Datatypes.cons y l2)) z ->
  path x l1 y /\ path y (Init.Datatypes.cons y l2) z.

Axiom lmem_dec :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (l:Init.Datatypes.list a),
  list.Mem.mem x l \/ ~ list.Mem.mem x l.

Axiom inter_com :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set.Fset.fset a) (s2:set.Fset.fset a),
  set.Fset.infix_eqeq (set.Fset.inter s1 s2) (set.Fset.inter s2 s1).

Axiom inter_add_l :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set.Fset.fset a) (s2:set.Fset.fset a) (x:a),
  set.Fset.mem x s2 ->
  set.Fset.infix_eqeq (set.Fset.inter (set.Fset.add x s1) s2)
  (set.Fset.add x (set.Fset.inter s1 s2)).

Axiom inter_not_add_l :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set.Fset.fset a) (s2:set.Fset.fset a) (x:a),
  ~ set.Fset.mem x s2 ->
  set.Fset.infix_eqeq (set.Fset.inter (set.Fset.add x s1) s2)
  (set.Fset.inter s1 s2).

Axiom diff_add_l :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s1:set.Fset.fset a) (s2:set.Fset.fset a),
  ~ set.Fset.mem x s2 ->
  set.Fset.infix_eqeq (set.Fset.diff (set.Fset.add x s1) s2)
  (set.Fset.add x (set.Fset.diff s1 s2)).

Axiom diff_not_add_l :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s1:set.Fset.fset a) (s2:set.Fset.fset a),
  set.Fset.mem x s2 ->
  set.Fset.infix_eqeq (set.Fset.diff (set.Fset.add x s1) s2)
  (set.Fset.diff s1 s2).

Axiom subset_add_r :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:set.Fset.fset a) (s':set.Fset.fset a),
  set.Fset.subset s' (set.Fset.add x s) ->
  set.Fset.mem x s' \/ set.Fset.subset s' s.

Axiom union_add_l :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:set.Fset.fset a) (s':set.Fset.fset a),
  set.Fset.infix_eqeq (set.Fset.union (set.Fset.add x s) s')
  (set.Fset.add x (set.Fset.union s s')).

Axiom union_add_r :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:set.Fset.fset a) (s':set.Fset.fset a),
  set.Fset.infix_eqeq (set.Fset.union s (set.Fset.add x s'))
  (set.Fset.add x (set.Fset.union s s')).

Axiom union_com :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset a) (s':set.Fset.fset a),
  set.Fset.infix_eqeq (set.Fset.union s s') (set.Fset.union s' s).

Axiom union_var_l :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset a) (s':set.Fset.fset a) (t:set.Fset.fset a),
  set.Fset.subset s s' ->
  set.Fset.subset (set.Fset.union s t) (set.Fset.union s' t).

Axiom union_var_r :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset a) (t:set.Fset.fset a) (t':set.Fset.fset a),
  set.Fset.subset t t' ->
  set.Fset.subset (set.Fset.union s t) (set.Fset.union s t').

Parameter set_of:
  forall {a:Type} {a_WT:WhyType a}, set.Fset.fset (set.Fset.fset a) ->
  set.Fset.fset a.

Axiom set_of_empty :
  forall {a:Type} {a_WT:WhyType a},
  ((set_of (set.Fset.empty : set.Fset.fset (set.Fset.fset a))) =
   (set.Fset.empty : set.Fset.fset a)).

Axiom set_of_add :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset a) (sx:set.Fset.fset (set.Fset.fset a)),
  set.Fset.infix_eqeq (set_of (set.Fset.add s sx))
  (set.Fset.union s (set_of sx)).

(* Why3 assumption *)
Definition one_in_set_of {a:Type} {a_WT:WhyType a}
    (sccs:set.Fset.fset (set.Fset.fset a)) : Prop :=
  forall (x:a), set.Fset.mem x (set_of sccs) ->
  exists cc:set.Fset.fset a, set.Fset.mem x cc /\ set.Fset.mem cc sccs.

Axiom Induction :
  (forall (s:set.Fset.fset (set.Fset.fset vertex)), set.Fset.is_empty s ->
   one_in_set_of s) ->
  (forall (s:set.Fset.fset (set.Fset.fset vertex)), one_in_set_of s ->
   (forall (t:set.Fset.fset vertex), one_in_set_of (set.Fset.add t s))) ->
  forall (s:set.Fset.fset (set.Fset.fset vertex)), one_in_set_of s.

Axiom set_of_elt :
  forall (sccs:set.Fset.fset (set.Fset.fset vertex)), one_in_set_of sccs.

Axiom elt_set_of :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (cc:set.Fset.fset a) (sccs:set.Fset.fset (set.Fset.fset a)),
  set.Fset.mem x cc -> set.Fset.mem cc sccs -> set.Fset.mem x (set_of sccs).

Axiom subset_set_of :
  forall (s:set.Fset.fset (set.Fset.fset vertex))
    (s':set.Fset.fset (set.Fset.fset vertex)),
  set.Fset.subset s s' -> set.Fset.subset (set_of s) (set_of s').

Axiom elts_cons :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (l:Init.Datatypes.list a),
  set.Fset.infix_eqeq (elements (Init.Datatypes.cons x l))
  (set.Fset.add x (elements l)).

Axiom elts_app :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:Init.Datatypes.list a) (s':Init.Datatypes.list a),
  set.Fset.infix_eqeq (elements (Init.Datatypes.app s s'))
  (set.Fset.union (elements s) (elements s')).

(* Why3 goal *)
Theorem list_simpl_r {a:Type} {a_WT:WhyType a} :
  forall (l1:Init.Datatypes.list a) (l2:Init.Datatypes.list a)
    (l:Init.Datatypes.list a),
  ((Init.Datatypes.app l1 l) = (Init.Datatypes.app l2 l)) -> (l1 = l2).
(* Why3 intros l1 l2 l h1. *)
Proof.
Require Import Lia.
induction l1.
simpl.
destruct l2; simpl; auto; intros.
assert (length l = length ((a0 :: l2 ++ l)%list)).
symmetry in H.
rewrite H; auto.
simpl in H0.
rewrite List.app_length in H0.
lia.

induction l2; intros; simpl in *.
assert (length ((a0 :: l1 ++ l)%list) = length l).
rewrite H; auto.
simpl in H0.
rewrite List.app_length in H0.
lia.

inversion H.
apply IHl1 in H2.
inversion H2.
auto.

Qed.

